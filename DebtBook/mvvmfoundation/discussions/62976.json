[
  {
    "Id": "213865",
    "ThreadId": "62976",
    "Html": "<p>Josh, have you considered as an alternative to your ObservableObject, using lambda's and expressions, similar to how you've implemented your PropertyObserver class?</p>\r\n<p>I've seen a couple of postings which use this technique, and the advantages would appear to be: removal of string literals (same as for your PropertyObserver), and secondly removal of the need to inherit your view model classes from a particular base class. &nbsp;(For me any time you can avoid implementation inheritance is good).</p>\r\n<p>Here are the links:</p>\r\n<p><a href=\"http://www.ingebrigtsen.info/post/2008/12/11/INotifyPropertyChanged-revisited.aspx\">http://www.ingebrigtsen.info/post/2008/12/11/INotifyPropertyChanged-revisited.aspx</a></p>\r\n<p><a href=\"http://www.ingebrigtsen.info/post/2009/07/11/Extensions-and-Helpers-for-Silverlight-and-WPF.aspx\">http://www.ingebrigtsen.info/post/2009/07/11/Extensions-and-Helpers-for-Silverlight-and-WPF.aspx</a></p>\r\n<p><a href=\"http://blogs.microsoft.co.il/blogs/dorony/archive/2007/08/31/WPF-Binding_2C00_-INotifyPropertyChanged-and-Linq.aspx\">http://blogs.microsoft.co.il/blogs/dorony/archive/2007/08/31/WPF-Binding_2C00_-INotifyPropertyChanged-and-Linq.aspx</a></p>\r\n<p>I'd be interested to know what you think - I can see some possible performance issues, but all things being equal avoiding string literals and base class requirements seems very attractive.</p>\r\n<p>Regards,</p>\r\n<p>Phil</p>",
    "PostedDate": "2009-07-20T09:21:20.45-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "213870",
    "ThreadId": "62976",
    "Html": "<p>Phil,</p>\r\n<p>I considered using lambdas to provide property names to ObservableObject's RaisePropertyChanged method, but decided not to implement it due to the performance implications. &nbsp;Since you only register handlers with PropertyObserver once per instance, the performance consideration is not very relevant. Property change notifications can happen very frequently and consistently throughout the life of an object.</p>\r\n<p>If someone provides me with performance test results showing that using the lambda approach is not all that bad, I might reconsider.&nbsp;</p>\r\n<p>Thanks,</p>\r\n<p>Josh</p>",
    "PostedDate": "2009-07-20T09:38:51.16-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "213942",
    "ThreadId": "62976",
    "Html": "<p>Josh, I'm taking a look at it r.e. performace; there certainly is a hit - extremely rough tests so far indicate approx a 30x overhead.</p>\r\n<p>However, what's interesting is that the vast majority of that appears to be in the reference to the lambda expression itself -&nbsp;</p>\r\n<p>If instead of directly including the lambda, you cache a single instance of it as member data you can bring it down to a 2x overhead. &nbsp;For example:</p>\r\n<p>Instead of:</p>\r\n<div id=\"_mcePaste\" style=\"left:-10000px;top:0px;width:1px;height:1px;overflow-x:hidden;overflow-y:hidden\">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;public string TextProperty</div>\r\n<div id=\"_mcePaste\" style=\"left:-10000px;top:0px;width:1px;height:1px;overflow-x:hidden;overflow-y:hidden\">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;{</div>\r\n<div id=\"_mcePaste\" style=\"left:-10000px;top:0px;width:1px;height:1px;overflow-x:hidden;overflow-y:hidden\">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;get { return _textProperty; }</div>\r\n<div id=\"_mcePaste\" style=\"left:-10000px;top:0px;width:1px;height:1px;overflow-x:hidden;overflow-y:hidden\">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;set</div>\r\n<div id=\"_mcePaste\" style=\"left:-10000px;top:0px;width:1px;height:1px;overflow-x:hidden;overflow-y:hidden\">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{</div>\r\n<div id=\"_mcePaste\" style=\"left:-10000px;top:0px;width:1px;height:1px;overflow-x:hidden;overflow-y:hidden\">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_textProperty = value;</div>\r\n<div id=\"_mcePaste\" style=\"left:-10000px;top:0px;width:1px;height:1px;overflow-x:hidden;overflow-y:hidden\">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PropertyChanged.Notify(m_textPropExpression);</div>\r\n<div id=\"_mcePaste\" style=\"left:-10000px;top:0px;width:1px;height:1px;overflow-x:hidden;overflow-y:hidden\">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//PropertyChanged.Notify(() =&gt; TextProperty);</div>\r\n<div id=\"_mcePaste\" style=\"left:-10000px;top:0px;width:1px;height:1px;overflow-x:hidden;overflow-y:hidden\">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}</div>\r\n<div id=\"_mcePaste\" style=\"left:-10000px;top:0px;width:1px;height:1px;overflow-x:hidden;overflow-y:hidden\">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;}</div>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<div style=\"color:Black;background-color:White\">\r\n<pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:Blue\">public</span> <span style=\"color:Blue\">string</span> TextProperty\r\n\r\n&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;{\r\n\r\n&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:Blue\">get</span> { <span style=\"color:Blue\">return</span> _textProperty; }\r\n\r\n&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:Blue\">set</span>\r\n\r\n&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{\r\n\r\n&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_textProperty = value;\r\n\r\n&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PropertyChanged.Notify(() =&gt; TextProperty);\r\n\r\n&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}\r\n\r\n&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;}\r\n\r\nWe cache the lambda expression:</pre>\r\n</div>\r\n<p>&nbsp;</p>\r\n<div style=\"color:Black;background-color:White\">\r\n<pre>   <span style=\"color:Blue\">public</span> <span style=\"color:Blue\">class</span><span style=\"color:MediumTurquoise\"> MyClass : INotifyPropertyChanged\r\n    </span>{\r\n        <span style=\"color:Blue\">public</span> <span style=\"color:Blue\">event</span> PropertyChangedEventHandler PropertyChanged;\r\n\r\n        <span style=\"color:Blue\">private</span> <span style=\"color:Blue\">string</span> _textProperty;\r\n\r\n        <span style=\"color:Blue\">public</span> MyClass()\r\n        {\r\n            _textPropExpression = () =&gt; TextProperty;\r\n        }\r\n\r\n        Expression&lt;Func&lt;<span style=\"color:Blue\">object</span>&gt;&gt; _textPropExpression;\r\n\r\n        <span style=\"color:Blue\">public</span> <span style=\"color:Blue\">string</span> TextProperty\r\n        {\r\n            <span style=\"color:Blue\">get</span> { <span style=\"color:Blue\">return</span> _textProperty; }\r\n            <span style=\"color:Blue\">set</span>\r\n            {\r\n                _textProperty = value;\r\n                PropertyChanged.Notify(_textPropExpression);\r\n            }\r\n        }\r\n    }\r\n</pre>\r\n</div>\r\n<p>&nbsp;</p>\r\n<p>I think a 2x overhead would be reasonable if a way could be found to cache the expression and still provide a reasonable API.</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2009-07-20T12:03:06.417-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "213956",
    "ThreadId": "62976",
    "Html": "<p>How's about the following (which **seems** from quick tests) to be performing equivalent to regular use of string literals. &nbsp;Here we use an additional member variable to cache a PropertyChangedEventArgs object which is used thereafter for each change notification for it's associated property.</p>\r\n<p>There is of course a perf hit on the first call, after that it's as quick (actually very marginally quicker - since we're not creating new PropertyChangedEventArgs objects). &nbsp;There's a slight code cost as well in the couple of extra lines (the var declaration and the caching code).</p>\r\n<p>It seems like a reasonable compromise though - no string literals so it's safe for refactoring tools, and in obfuscation safe.</p>\r\n<p>Code snippet:</p>\r\n<div id=\"_mcePaste\" style=\"left:-10000px;top:0px;width:1px;height:1px;overflow-x:hidden;overflow-y:hidden\">&nbsp;&nbsp; &nbsp;public static class PropChangeHelper</div>\r\n<div id=\"_mcePaste\" style=\"left:-10000px;top:0px;width:1px;height:1px;overflow-x:hidden;overflow-y:hidden\">&nbsp;&nbsp; &nbsp;{</div>\r\n<div id=\"_mcePaste\" style=\"left:-10000px;top:0px;width:1px;height:1px;overflow-x:hidden;overflow-y:hidden\">&nbsp;&nbsp; &nbsp; &nbsp;public static PropertyChangedEventArgs CreateArgs(Expression&lt;Func&lt;object&gt;&gt; propertyExpression)</div>\r\n<div id=\"_mcePaste\" style=\"left:-10000px;top:0px;width:1px;height:1px;overflow-x:hidden;overflow-y:hidden\">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;{</div>\r\n<div id=\"_mcePaste\" style=\"left:-10000px;top:0px;width:1px;height:1px;overflow-x:hidden;overflow-y:hidden\">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;var lambda = propertyExpression as LambdaExpression;</div>\r\n<div id=\"_mcePaste\" style=\"left:-10000px;top:0px;width:1px;height:1px;overflow-x:hidden;overflow-y:hidden\">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;MemberExpression memberExpression;</div>\r\n<div id=\"_mcePaste\" style=\"left:-10000px;top:0px;width:1px;height:1px;overflow-x:hidden;overflow-y:hidden\">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (lambda.Body is UnaryExpression)</div>\r\n<div id=\"_mcePaste\" style=\"left:-10000px;top:0px;width:1px;height:1px;overflow-x:hidden;overflow-y:hidden\">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{</div>\r\n<div id=\"_mcePaste\" style=\"left:-10000px;top:0px;width:1px;height:1px;overflow-x:hidden;overflow-y:hidden\">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;var unaryExpression = lambda.Body as UnaryExpression;</div>\r\n<div id=\"_mcePaste\" style=\"left:-10000px;top:0px;width:1px;height:1px;overflow-x:hidden;overflow-y:hidden\">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;memberExpression = unaryExpression.Operand as MemberExpression;</div>\r\n<div id=\"_mcePaste\" style=\"left:-10000px;top:0px;width:1px;height:1px;overflow-x:hidden;overflow-y:hidden\">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}</div>\r\n<div id=\"_mcePaste\" style=\"left:-10000px;top:0px;width:1px;height:1px;overflow-x:hidden;overflow-y:hidden\">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;else</div>\r\n<div id=\"_mcePaste\" style=\"left:-10000px;top:0px;width:1px;height:1px;overflow-x:hidden;overflow-y:hidden\">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{</div>\r\n<div id=\"_mcePaste\" style=\"left:-10000px;top:0px;width:1px;height:1px;overflow-x:hidden;overflow-y:hidden\">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;memberExpression = lambda.Body as MemberExpression;</div>\r\n<div id=\"_mcePaste\" style=\"left:-10000px;top:0px;width:1px;height:1px;overflow-x:hidden;overflow-y:hidden\">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}</div>\r\n<div id=\"_mcePaste\" style=\"left:-10000px;top:0px;width:1px;height:1px;overflow-x:hidden;overflow-y:hidden\">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;var propertyInfo = memberExpression.Member as PropertyInfo;</div>\r\n<div id=\"_mcePaste\" style=\"left:-10000px;top:0px;width:1px;height:1px;overflow-x:hidden;overflow-y:hidden\">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return new PropertyChangedEventArgs(propertyInfo.Name);</div>\r\n<div id=\"_mcePaste\" style=\"left:-10000px;top:0px;width:1px;height:1px;overflow-x:hidden;overflow-y:hidden\">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;}</div>\r\n<div id=\"_mcePaste\" style=\"left:-10000px;top:0px;width:1px;height:1px;overflow-x:hidden;overflow-y:hidden\">&nbsp;&nbsp; &nbsp;</div>\r\n<div style=\"color:Black;background-color:White\">\r\n<pre>    <span style=\"color:Blue\">public</span> <span style=\"color:Blue\">static</span> <span style=\"color:Blue\">class</span><span style=\"color:MediumTurquoise\"> PropChangeHelper\r\n    </span>{\r\n        <span style=\"color:Blue\">public</span> <span style=\"color:Blue\">static</span> PropertyChangedEventArgs CreateArgs(Expression&lt;Func&lt;<span style=\"color:Blue\">object</span>&gt;&gt; propertyExpression)\r\n        {\r\n            <span style=\"color:Blue\">var</span> lambda = propertyExpression <span style=\"color:Blue\">as</span> LambdaExpression;\r\n            MemberExpression memberExpression;\r\n            <span style=\"color:Blue\">if</span> (lambda.Body <span style=\"color:Blue\">is</span> UnaryExpression)\r\n            {\r\n                <span style=\"color:Blue\">var</span> unaryExpression = lambda.Body <span style=\"color:Blue\">as</span> UnaryExpression;\r\n                memberExpression = unaryExpression.Operand <span style=\"color:Blue\">as</span> MemberExpression;\r\n            }\r\n            <span style=\"color:Blue\">else</span>\r\n            {\r\n                memberExpression = lambda.Body <span style=\"color:Blue\">as</span> MemberExpression;\r\n            }\r\n\r\n            <span style=\"color:Blue\">var</span> propertyInfo = memberExpression.Member <span style=\"color:Blue\">as</span> PropertyInfo;\r\n\r\n            <span style=\"color:Blue\">return</span> <span style=\"color:Blue\">new</span> PropertyChangedEventArgs(propertyInfo.Name);\r\n        }\r\n    }\r\n\r\n</pre>\r\n</div>\r\n<div style=\"color:Black;background-color:White\">\r\n<pre>    <span style=\"color:Blue\">public</span> <span style=\"color:Blue\">class</span><span style=\"color:MediumTurquoise\"> MyClass : INotifyPropertyChanged\r\n    </span>{\r\n\r\n        <span style=\"color:Green\">// .... rest of code snipped</span>\r\n\r\n        PropertyChangedEventArgs _textPropertyChanged;\r\n        <span style=\"color:Blue\">public</span> <span style=\"color:Blue\">string</span> TextProperty\r\n        {\r\n            <span style=\"color:Blue\">get</span> { <span style=\"color:Blue\">return</span> _textProperty; }\r\n            <span style=\"color:Blue\">set</span>\r\n            {\r\n                _textProperty = value;\r\n\r\n                <span style=\"color:Blue\">if</span>(_textPropertyChanged == <span style=\"color:Blue\">null</span>) _textPropertyChanged = PropChangeHelper.CreateArgs(() =&gt; TextProperty);\r\n\r\n                PropertyChanged(<span style=\"color:Blue\">this</span>, _textPropertyChanged);\r\n            }\r\n        }\r\n\r\n</pre>\r\n</div>\r\n<p>What do you think?</p>\r\n<p>&nbsp;</p>\r\n<p>p.s. come to think of it, there's probably no reason we can't make the cached event args reference static, and usually only take a perf hit once per class rather than per instance.</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2009-07-20T12:41:18.287-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "217618",
    "ThreadId": "62976",
    "Html": "<p>Josh, I've posted the following suggestion to Sacha Barber as well...</p>\r\n<p>I think this is now a pretty decent solution to use of static reflection (lamba expressions) for property change notifications which doesn't have a performance hit.</p>\r\n<p>In fact, according to my rough tests it's approx 40% faster than the usual practice of newing up a PropertyChangedEventArgs object with a string for each change notification.</p>\r\n<p>Here's the code (Observable) plus an example usage (Person):</p>\r\n<p>public class Observable&lt;T&gt; : INotifyPropertyChanged<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; where T : Observable&lt;T&gt;<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public event PropertyChangedEventHandler PropertyChanged;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; protected static PropertyChangedEventArgs CreateArgs(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Expression&lt;Func&lt;T, object&gt;&gt; propertyExpression)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var lambda = propertyExpression as LambdaExpression;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemberExpression memberExpression;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (lambda.Body is UnaryExpression)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var unaryExpression = lambda.Body as UnaryExpression;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memberExpression = unaryExpression.Operand as MemberExpression;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memberExpression = lambda.Body as MemberExpression;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var propertyInfo = memberExpression.Member as PropertyInfo;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return new PropertyChangedEventArgs(propertyInfo.Name);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; protected void NotifyChange(PropertyChangedEventArgs args)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PropertyChanged != null)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PropertyChanged(this, args);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; public class Person : Observable&lt;Person&gt;<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // property change event arg objects<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static PropertyChangedEventArgs _firstNameChangeArgs = CreateArgs(x =&gt; x.FirstName);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static PropertyChangedEventArgs _lastNameChangeArgs = CreateArgs(x =&gt; x.LastName);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string _firstName;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string _lastName;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public string FirstName<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get { return _firstName; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _firstName = value;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NotifyChange(_firstNameChangeArgs);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public string LastName<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get { return _lastName; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _lastName = value;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NotifyChange(_lastNameChangeArgs);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2009-07-30T08:13:11.187-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "217656",
    "ThreadId": "62976",
    "Html": "<p>That's pretty nice! &nbsp;Aside from the fact that the subclasses must manage event argument instances, I think that's a nice way to leverage the compile-time safety of expressions without the performance loss. &nbsp;I'll think about adding a new overload of RaisePropertyChanged to ObservableObject that takes in the event arg...Thanks!</p>",
    "PostedDate": "2009-07-30T09:39:56.16-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "217813",
    "ThreadId": "62976",
    "Html": "<p>Cool! Thanks!</p>\r\n<p>Josh, note, and I think you'll already have though of this, but.. think it will still be desirable for there to be a call into your VerifyPropertyName method for the debug build - there's still after all the possibility of the developer using this passing in the wrong event args object.</p>\r\n<p>And means a lot to me that you like any piece of code of mine - no matter how small - I've been reading a lot of your MVVM and WPF articles and you've been a great help to me as a result :)</p>\r\n<p>Phil</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2009-07-30T17:10:05.727-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "218088",
    "ThreadId": "62976",
    "Html": "<p>I'm not sure there's a need for verifying the property name if the user is passing in the eventargs. &nbsp;VerifyPropertyName() only ensures that the specified name corresponds to a public property on the object...it does not ensure that the property that is being set matches the name of said property. &nbsp;Also, sometimes when setting a property there is a need to raise PropertyChanged for other properties whose values are dependent upon the value of the property being set. In that case, we wouldn't want VerifyPropertyName() to consider that to be erroneous.</p>",
    "PostedDate": "2009-07-31T09:59:17.78-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "218167",
    "ThreadId": "62976",
    "Html": "<p>Ah, gotcha - i thought you were walking the callstack to check the property name. &nbsp;In any case you're right, it wouldn't be a good idea for the reason you describe.</p>\r\n<p>Phil</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2009-07-31T14:33:26.473-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "220367",
    "ThreadId": "62976",
    "Html": "<p>A quick note, on the code snippet I posted Josh - there's a problem with it - the CreateArgs method is constrained to T which is specified by the inheriting class as itself.<br><br>I did this in an attempt to avoid having to have the user of the method explicitly specify the type of T, which otherwise it has to do since it is used from static scope.<br><br>Unfortunately I think&nbsp;this isn't going to work since it constrains T to the immediate subtype. This is all well and good if that's the final class and there aren't any further levels of inheritance.<br><br>So, for example if we were to subclass Person, as it stands with the posted code, the subclass would not be able to create property change arg objects for it's own properties, only those of Person.<br><br>I'm on vacation right now, so I'll take another look at it later, but the most obvious way to resolve this would seem to be to make CreateArgs a generic method, and have the caller explictly state the type for T. We can also possibly remove the base class Observable, but should at least make it non-generic since specialization on T for the base class no longer serves any purpose.<br><br>Regards,<br>Phil</p>",
    "PostedDate": "2009-08-06T07:33:39.213-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "220415",
    "ThreadId": "62976",
    "Html": "<p>Thanks Phil. &nbsp;I was against making ObservableObject generic, so that was never on my radar. &nbsp;Thanks for pointing out that problem, though. &nbsp;It's another reason to not make it generic. &nbsp;:)</p>\r\n<p>Josh</p>",
    "PostedDate": "2009-08-06T08:54:48.873-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]